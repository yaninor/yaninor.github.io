<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用canvas制作一个简单的随机验证码]]></title>
    <url>%2F2019%2F01%2F12%2Fcanvas%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[现在验证码在网页表单中几乎是标配，用来防止机器人攻击网站，今天我们就用canvas和js来写一个简单的随机二维码。 制作思路大家知道canvas是HTML5里面的新特性，可以用来绘图，配合js可以绘制出各种各样的图案。验证码一般由数字或字母组成，再加上一些视觉干扰的元素，防止机器人识别。而canvas可以绘制文字及线条，还可以做一些旋转处理，利用这些特性我们就可以做出一个简单的随机验证码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width="200" height="30" id="myCanvas"&gt;&lt;/canvas&gt; &lt;br&gt; &lt;input type="text" name="" placeholder="请输入验证码" id="input"&gt; &lt;button onclick="check()"&gt;验证&lt;/button&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var c=document.getElementById("myCanvas"); var ctx=c.getContext("2d"); ctx.fillStyle="#BFEFFF";//绘制背景颜色 ctx.fillRect(0,0,160,30); //随机产生4个字符 var chars = []; for(var i = 0;i &lt; 4;i++)&#123; chars.push(Math.floor(Math.random()*9).toString()); &#125; ctx.font="20px Verdana"; var x = 15; var colors = ['red','yellow','blue','green','pink','black']; //绘制4个字符 for(i = 0;i &lt; 4;i++)&#123; ctx.fillStyle = colors[Math.floor(Math.random()*5)]; ctx.fillText(chars[i],x,25); x = x + 40; &#125; //对图案随机加入线条造成干扰 var lineNumber = 5; // 线条条数 var lineX = 160; var lineY = 30; // 最大线条坐标 for(i = 0;i &lt; lineNumber;i++)&#123; ctx.strokeStyle = colors[Math.floor(Math.random()*5)]; ctx.beginPath(); ctx.moveTo(Math.floor(Math.random()*lineX),Math.floor(Math.random()*lineY)); ctx.lineTo(Math.floor(Math.random()*lineX),Math.floor(Math.random()*lineY)); ctx.stroke(); &#125; // 点击按钮验证 function check()&#123; var input = document.getElementById('input').value; if(input === chars.join(''))&#123; alert("验证成功"); &#125; else&#123; alert('验证失败'); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 最后的效果：（每一次刷新后的图案都是不同的） 当然这里使用的是数字，你也可使用字母或数字字母混用。在干扰方面，你还可以加上旋转，缩放，虚化等等，这些效果用canvas同样可以实现。 以上。]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[炫酷的canvas粒子特效]]></title>
    <url>%2F2019%2F01%2F12%2Fcanvas%2F</url>
    <content type="text"><![CDATA[随着html5Canvas元素的推出呢，现在的浏览器具备了更强大的绘制图像的功能，甚至canvas已经可以用来制作大型网页游戏，关于Canvas的js库也越来越多，有动画库还有图表库比如Echart等等。今天我就要给大家推荐两款非常炫酷的Canvas粒子特效，let’s hit the road! Particleground粒子背景articleground是一款时髦的jquery粒子系统背景插件，PC端可通过鼠标控制视差效果，而移动端可用重力感应控制，Particleground可以运行在任何支持html5 canvas的浏览器上。 大家可以先看看效果。 怎么样是不是很炫酷！！那么要使用这个特效也是非常的简单。 首先放上项目的github地址。把代码clone下来到本地。然后引入它。12&lt;script type='text/javascript' src='jquery-3.0.0.min.js'&gt;&lt;/script&gt;&lt;script type='text/javascript' src='jquery.particleground.min.js'&gt;&lt;/script&gt; 注意这个组件是基于jQuery的，所以在你也需要引入JQuery文件。 然后在html里面添加一个Canvas容器：1&lt;div id="particles"&gt;&lt;/div&gt; 最后在js中将它初始化：1$('#particles').particleground(); 这样你的设置就完成了 当然你也可以设置参数：1234$('#particles').particleground(&#123;dotColor: '#ff0000', // 点的颜色lineColor: '#ff0000' // 线的颜色&#125;); 更多具体的参数请参阅官方文档。 canvas-nest.js粒子背景接下来是另一款粒子背景，它和上面的 Particleground 有些不一样，粒子并不是随机分散的而是聚集在鼠标的周围，这样可以很清除的反应鼠标的位置。 在这里查看背景预览。 使用这款组件非常的容易，只需要在你的页面中加入这段代码即可（注意要放在body里面）1&lt;script src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"&gt;&lt;/script&gt; 是不是异常的简单！！ 当然你也可以下载文件到本地，这里是项目的地址。 同样的你可以设置动画参数，只需要在script标签里面添加就行了，像这样：1&lt;script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"&gt;&lt;/script&gt; 上面的参数分别是线条颜色、线条透明度、z轴值、以及粒子个数。 更多的参数请参阅项目文档。 要提醒一点的是，不管你使用哪个组件，不要将粒子的数量设置得太多，这样浏览器的性能会跟不上，毕竟图像绘制还是很吃性能的，浏览器甚至还会崩溃卡死。 好了，就介绍到这里了，祝各位小伙伴玩得愉快哦。]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记-Set和Map]]></title>
    <url>%2F2019%2F01%2F12%2FES6%E7%9A%84set%E5%92%8Cmap%2F</url>
    <content type="text"><![CDATA[大家知道，在ES5中，我们拥有两种数据数据结构，Array和Object。但是它们的功能还不够全面。于是在ES6中又为我们提供了两个新的数据结构，Set和Map。 Set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，也展示了一种去除数组重复成员的方法。12// 去除数组的重复成员[...new Set(array)] 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 要注意的是，两个对象总是被认为是不相等的。1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。12345const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 Map基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 事实上，不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 WeakMapWeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将数值1和Symbol值作为WeakMap的键名，都会报错。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记-箭头函数]]></title>
    <url>%2F2019%2F01%2F12%2FES6%2F</url>
    <content type="text"><![CDATA[箭头函数是ES6中一个新增的特性，今天我们就来看看它是如何使用的。 基本用法ES6 允许使用“箭头”（=&gt;）定义函数。1var f = v =&gt; v; 等同于123var f = function(v) &#123; return v;&#125;; 我们可以看到箭头前面的 v 是作为函数的参数，箭头后面的 v 是作为函数的返回值，那么箭头函数的结构差不多就明了了。 如果你不需要参数，或需要多个参数，就使用一个圆括号在参数部分，也就是箭头的前面：12345var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 通过之前的例子我们可以知道，箭头后面的内容就是函数要返回的内容，但这仅限于函数体用一句语句就可以解决的情况，如果函数体拥有一句以上的语句，你需要将函数体中的语句用大括号括起来，并仍然需要使用return语句将返回值返回：1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 如果你想要返回一个对象，必须用括号将这个对象括起来：1var id = x =&gt;(&#123; id : x , name : 'name' &#125;) 箭头函数可以与变量解构结合使用。123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数的作用对于箭头函数的作用，个人认为有三点： 箭头函数使函数的表达更为简洁。 对于简单的一些功能函数，箭头函数相比于传统函数的表达更为简洁，并且代码量也更少，通常只需要一行。 简化回调函数： 1234567 // 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 这样使代码更加简洁也更加易读。 箭头函数可以将this对象绑定在定义时的作用域中，这种特性非常利于封装回调函数： 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 使用箭头函数时要注意 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 这大概就是对箭头函数的大致介绍了，其他的还要小伙伴们自己去探索，祝大家学习愉快哦。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的php总结]]></title>
    <url>%2F2019%2F01%2F12%2Fphp%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PHP常见错误收集Fatal error: Non-static method Conn::__construct() cannot be called statically in /file.php 没有静态的方法(里面这个指方法参数，字符串类型),不能从静态上下文引用。 Fatal error: operator not supported for strings in /file.php 当一个变量已设为非数组类型的时候，就不能再次使用[]让同名变量增加数据键值 解决方法： 1.改变变量名称、 2.使用$var = array(…) 举例： 123456789101112&lt;?php//这里为字符串类型 $err = $e-&gt;getMessage();//当执行到这里的时候会报错 $err[] = array ( &apos;gid&apos; =&gt; $this-&gt;_get[&apos;id&apos;], &apos;url&apos; =&gt; $new, &apos;log&apos; =&gt; $err, &apos;time&apos; =&gt; time() );?&gt;` Fatal error: Declaration of Listing::content() must be compatible with that of InewsList::content() in file\List_1.phpon line 7 统一接口所有类方法都必须和接口规定的一致：作用域声明、方法名、参数数量 Parse error: syntax error, unexpected T_NAMESPACE, expecting T_STRING in file\List_1.php on line 42 检查语句是否闭合，例如：()、”” 检查是否有命名冲突，例如：namespace Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 6144 bytes) in file\List_1.php on line 8 内存超过PHP默认设置的128M Notice: Undefined property: News::$_matches in file\List_1.php on line 57 没有找到类中的方法 Warning: preg_match_all() [function.preg-match-all]: Empty regular expression in file\List_1.php on line 57 正则表达式为空 Warning: preg_match_all() [function.preg-match-all]: Delimiter must not be alphanumeric or backslash infile\List_1.php on line 57 判断为第一个参数的正则表达式写法有问题 记得在前面和后面加上 / 符号。 Warning: mysqli::query() [mysqli.query]: Couldn’t fetch Insert in /file.php 必须使用mysqli链接数据库后返回的结果集去执行操作。 Warning: 1064_You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near… 网上搜索是MYSQL兼容问题，实际操作上是语法错误，需检查SQL语句写的是否正确。 Warning: array_shift() expects parameter 1 to be array, integer given 函数第一个参数必须是一个数组。 Fatal error: Unsupported operand types in file\List_1.php on line 60 致命错误：不支持的操作数据类型产生原因，将不符合数据类型的数据传送给了某些函数。比如我就不小心将一个数组传给了我的一个自定义函数，而这个函数接受的参数应该是数字。 Fatal error: Only variables can be passed by reference in …… 在PHP里，如果运行以下代码： 123456&lt;?phpfunction eee(&amp;$t) &#123; $w = &apos;hello &apos;.$t; return $w; &#125; echo eee(&apos;World&apos;);?&gt; 意思是“只有变量能通过‘引用’”。 Warning: Illegal offset type in isset or empty in 前几天写程序的时候碰到一个这种错误提示如果你使用这样的表示方法如下： 123456&lt;?php$arr = array();class a &#123;&#125; $o = new a;echo $arr[$o];?&gt; 就会出现上面的错误提示，因为不能使用实例化的对象来作为数组的索引，或者在使用isset empty检测这样的数据的时候也会出现第二种情况。如果在做实际中碰到这样的错误提示，查看数组变量的键名是否使用了实例化的对象变量作为键名 #1366 - Incorrect integer value: ‘’ for column ‘ID’ at row 1 mysql版本为msyql 5.1.14 WIN32版本,出现错误的原因是没有给自增ID赋值,尽管之前的版本可以不赋值,自动增加,但是在新版本的msyql中需要为其赋值NULL #1136:Column count doesn’t match value count at row 1 检查一下有没有序号自增加的字段。 所存储的数据与数据库表的字段类型定义不相匹配. 字段类型是否正确, 是否越界, 有无把一种类型的数据存储到另一种数据类型中. SQL语句里列的数目和后面的值的数目不一致 #1062_Duplicate entry ‘…’ for key ‘map’ 关键字重复、可能是主键ID、也可能是唯一字段。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php与bom头的惨痛经历]]></title>
    <url>%2F2019%2F01%2F12%2Fphp%2F</url>
    <content type="text"><![CDATA[记一次“惨痛”的上线bug经历：php与BOM头 经验往往是伴随着“惨痛”的教训而来，比如说最近的这次。事情的起因，源于最近的一次上线：手机客户端的“微博视频广场”代码修改上线后，页面突然异常，模块展示各种混乱，整个视频广场都变得“不好了”。。。 1.查找bug原因 有了问题就要查找原因。首先想到的是调用接口返回的数据异常。但是手动调用接口（浏览器调用&amp;终端curl调用），返回的json格式数据都是正确的，接口输出“看起来”没有问题。 无奈之下，只得求助于接口调用方，经过不断的打断点调试，终于在接口输出json数据的开头，发现了诡异的“\ufeff”字符（见下图）！！！而恰恰由于这几个字符，导致了接口输出的json串解析失败！ 马上百度之，发现返回结果中都提到了“BOM头”！原来是BOM头捣的鬼！bug的原因终于找到了！ 也许看到这，你不禁想问什么是BOM头？不要急，下面就跟大家介绍下~ 2.php与BOM头 BOM（Byte Order Mark）是一个字节顺序标签，类似一个标记，又叫签名，用来告诉编辑器当前文件采用何种编码，方便编辑器识别。除了unicode编码，一般的编码集并不会出现bom头。对于utf-16和utf-32，如果不指定bom头，解析程序就默认为ansi编码，从而出现乱码；而对于utf-8，BOM头指定与否，解析程序都可判断。 现在几乎所有的文本编辑软件都可以显示并编辑UTF-8编码的文件，但其中很多的表现并不理想。类似WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符0xEF、0xBB和0xBF，即BOM。对于一般的文件，这样做并不会产生麻烦。但对于 PHP来说，BOM是个大麻烦。因为PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文的一部分。同时根据嵌入式语言的特点，这串字符最终将被直接执行（显示）出来。 回到我们的问题中，由于有个配置文件在开发时用WINDOWS自带的记事本编辑保存过，导致这个文件在开头加入了BOM头，而这个配置文件在各个php接口脚本中都被读取过，从而导致接口输出的json格式数据前面多了BOM头。 3.bug解决办法 找到了问题原因，解决方法就很简单了：把utf-8编码文件的BOM头去掉。可以编写程序，检测文件头的三个字符是否为0xEF、0xBB和0xBF，如果是的话，直接删除掉即可；也可以用下文提到的靠谱的编辑器，打开文件重新编辑，设置为无BOM头的utf-8编码。例如Notepad++的使用如下图： 4.经验总结 写到这里回头看，其实问题的原因很简单，但却很隐蔽，导致排查问题、查找原因的过程十分痛苦纠结。事后我也在不断思考，试图去总结些普遍试用的经验教训，以避免同类问题的再次发生。以下是一点浅见。 最最重要的教训，就是不要忽略测试！这里说的测试，不是自己开发完自己测，而是由QA，在上线前执行标准化的测试流程！这也是避免非环境原因导致隐蔽bug的有效措施之一！ 其次，就是上线前通过svn合代码进行code review时，不忽视任何细小的改动。BOM头是在文件开头添加了3个字符，在新旧代码的对比中，其实这种改动svn也会检测出来；但限于svn编辑器无法显示BOM头，直观的看，文件的开头好像多了个空格，但实际什么都没有。遇到这种情况，很大可能性就是BOM头捣的鬼！ 此外，在编辑、更改任何文本文件时，不要使用乱加BOM的编辑器！尤其是WINDOWS下，不要使用记事本做编辑器！！！ 推荐几个靠谱的编辑器：Editplus，Notepad++，EmEditor，UltraEdit，Dreamweaver（需要取消‘添加BOM’的相关选项）等。 5.BOM头对php程序的其他危害 BOM头对php程序的危害，最典型、最严重的，还不是上文提到的情况。如果在涉及到COOKIE实现的php文件中有BOM头，由于在COOKIE送出前PHP已经送出了文件头，那么受COOKIE送出机制的限制，COOKIE将无法送出，导致登入和登出功能失效！一切依赖COOKIE、SESSION实现的功能都将无效！ 另外一个典型危害：如果php程序实现xml格式的数据输出，并且php文件有BOM头，那么会造成输出的xml格式数据解析失败！]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 重写历史]]></title>
    <url>%2F2019%2F01%2F12%2FGit%20%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。Git 允许重写已经发生的提交，这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，或完全地移除提交。 1 修改最后一次提交修改最近一次提交可能是所有修改历史提交的操作中最常见的一个。对于最近一次提交，往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。 1$ git commit --amend 这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。 使用 Sourcetree 打开项目会发现有两个 master，检查最新的 master 分支无误后，执行强制推送远端命令。 1$ git push origin master -f 2 修改多个提交信息修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。 修改最近的两次提交 1$ git rebase HEAD~2 -i 也可以直接指定 commit 跳转 git rebase f20830d -i 运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样： 123456789101112131415161718192021pick cedeedc no1 messagepick f20830d no message# Rebase 3d1e0ad..f20830d onto 3d1e0ad (2 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 需要注意的是这里展示的提交顺序是由 HEAD~2 到 HEAD。修改脚本可以将 pick 修改为 Commands 提示的如 reword、edit 修改提交的日志。还可以使用 squash、fixup 合并提交。 将倒数第二个提交，使用 edit 编辑后，如下所示。 如果只修改信息建议使用 reword 命令。 12edit cedeedc no1 messagepick f20830d no message 当保存并退出(:wq)编辑后，Git会提交如下信息 123456789$ git rebase HEAD~2 -iStopped at 57f3a5b... no1yj messageYou can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 输入 1$ git commit --amend 编辑提交信息，然后，运行。 1$ git rebase --continue 这个命令将会自动地应用另外一个提交，然后就完成了。 最后使用 Sourcetree 打开项目，检查最新的 master 分支和对应的 tag 无误后，执行强制推送远端命令。 3 修改提交邮箱地址通过 filter-branch 可以一次性修改多个提交中的邮箱地址。需要注意只修改自己的邮箱地址，所以你使用 –commit-filter： 123456789$ git filter-branch --commit-filter &apos; if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ]; then GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;; GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;; git commit-tree &quot;$@&quot;; else git commit-tree &quot;$@&quot;; fi&apos; HEAD 全部更新 1$ git filter-branch --commit-filter &apos;GIT_AUTHOR_NAME=&quot;阳君&quot;;GIT_AUTHOR_EMAIL=&quot;937447973@qq.com&quot;;git commit-tree &quot;$@&quot;;fi&apos; HEAD &#160; AppendixRelated DocumentationGit 工具 - 重写历史 CopyrightCSDN：http://blog.csdn.net/y550918116j GitHub：https://github.com/937447974]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 生成SSH key]]></title>
    <url>%2F2019%2F01%2F12%2Fkey%2F</url>
    <content type="text"><![CDATA[使用git的过程中，我们会初始化创建关联服务器的SSH key. 1 设置用户名和邮箱开发过程中，提交的时候会在log中显示用户名和密码，便于管理。 12$ git config --global user.name &quot;阳君&quot;$ git config --global user.email &quot;937447974@qq.com&quot; 2 检查现有的SSH keys在创建SSH keys之前，我们可以看看电脑内是否有SSH keys秘钥。 打开Terminal输入如下命令。 1$ ls -al ~/.ssh 或输入 1$ ls ~/.ssh 如果看见如下文件，则代表SSH keys已创建好。 id_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub 查看已创建好的SSH key，使用如下命令。 1$ cat ~/.ssh/id_rsa.pub 3 生成新的SSH key如果没创建SSH key，我们可以创建新的SSH key。 1 设置电子邮件并创建对应的key 123$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# Creates a new ssh key, using the provided email as a labelGenerating public/private rsa key pair. 2 设置文件存储位置，直接“回车”。 1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 3 设置密码时，可设置空密码。 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 4 添加SSH key到ssh-agent12345# start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot;Agent pid 59566$ssh-add ~/.ssh/id_rsa 此时SSH key创建完毕。 &#160; AppendixRelated DocumentationGenerating an SSH key Revision History 时间 描述 2016-03-01 博文完成 CopyrightCSDN：http://blog.csdn.net/y550918116j GitHub：https://github.com/937447974/Blog]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git commit 规范]]></title>
    <url>%2F2019%2F01%2F11%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[在多人协作项目中，良好的 commit 风格如下所示 这里使用的工具是 commitlint。 1 Commitlint message 的格式Commitlint 基于 Angular 的规范。很多工具也是基于此规范, 它的 message 格式如下: 123456// Header&lt;type&gt;(scope): &lt;subject&gt;// 空一行Body// 空一行Footer Header 是必需的，注意冒号后面有空格，Body 和 Footer 可以省略。 Header：Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需） type：用于说明 commit 的类型，被指定在 commitlint.config.js 的 type-enum。 scope: 用于说明 commit 的影响范围，可以省略。 subject：subject 是 commit 目的的简短描述，不超过50个字符，且结尾不加句号（.）。 Body: body 部分是对本次 commit 的描述，可以分成多行。 Footer: footer 用于不兼容变动和关闭ISSUE。 2 Commitlint 安装2.1 commitlint.config.jsgit 根目录新建 commitlint.config.js 文件，添加如下代码。 12345678910111213141516171819202122module.exports = &#123; extends: [&apos;@commitlint/config-conventional&apos;], rules: &#123; &apos;subject-case&apos;: [0, &apos;never&apos;], &apos;type-enum&apos;: [ 2, &apos;always&apos;, [ &quot;docs&quot;, // Adds or alters documentation. 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等 &quot;chore&quot;, // Other changes that don&apos;t modify src or test files. 改变构建流程、或者增加依赖库、工具等 &quot;feat&quot;, // Adds a new feature. 新增feature &quot;fix&quot;, // Solves a bug. 修复bug &quot;merge&quot;, // Merge branch ? of ?. &quot;perf&quot;, // Improves performance. 优化相关，比如提升性能、体验 &quot;refactor&quot;, // Rewrites code without feature, performance or bug changes. 代码重构，没有加新功能或者修复bug &quot;revert&quot;, // Reverts a previous commit. 回滚到上一个版本 &quot;style&quot;, // Improves formatting, white-space. 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 &quot;test&quot; // Adds or modifies tests. 测试用例，包括单元测试、集成测试等 ] ] &#125;&#125;; 2.2 package.json命令行进入 git 根目录，执行 npm init 创建 package.json。 打开 package.json 粘贴如下代码。 123&quot;scripts&quot;: &#123; &quot;commitmsg&quot;: &quot;commitlint -E GIT_PARAMS&quot;&#125; 执行命令 npm install --save-dev @commitlint/{cli,config-conventional} husky 安装 commitlint 和 husky。 安装完毕后，打开 package.json 后如下所示。 12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;yjcocoa&quot;, &quot;version&quot;: &quot;8.3.0&quot;, &quot;description&quot;: &quot;YJ系列开源库&quot;, &quot;author&quot;: &quot;阳君&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;homepage&quot;: &quot;https://github.com/937447974/YJCocoa&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/937447974/YJCocoa.git&quot; &#125;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/937447974/YJCocoa/issues&quot; &#125;, &quot;main&quot;: &quot;commitlint.config.js&quot;, &quot;devDependencies&quot;: &#123; &quot;@commitlint/cli&quot;: &quot;^7.0.0&quot;, &quot;@commitlint/config-conventional&quot;: &quot;^7.0.1&quot;, &quot;husky&quot;: &quot;^0.14.3&quot; &#125;, &quot;scripts&quot;: &#123; &quot;commitmsg&quot;: &quot;commitlint -E GIT_PARAMS&quot;, &quot;commit&quot;: &quot;commit&quot; &#125;&#125; 执行测试命令如下所示，验证 commitlint 是否起效。123&lt;p align=&quot;center&quot;&gt; &lt;img width=&quot;600&quot; src=&quot;https://cdn.rawgit.com/marionebl/commitlint/3594397919c6188ce31ccfc94a0113d625d55516/docs/assets/commitlint.svg&quot;&gt;&lt;/p&gt;测试通过后，将 123# Nodenode_modules/package-lock.json 添加到 .gitignore，检查本地代码后提交并推送到服务器。 团队其他人员 pull 代码后，命令行进入 git 根目录执行 npm install 即可使用 commitlint 提交规范。 &#160; AppendixRelated Documentationcommitlint git commit 提交规范 &amp; 规范校验 Git Commint规范 CopyrightCSDN：http://blog.csdn.net/y550918116j GitHub：https://github.com/937447974]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
